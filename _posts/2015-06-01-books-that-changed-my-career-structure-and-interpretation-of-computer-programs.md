---
layout: post
title: Books that changed my career - Structure and Interpretation of Computer Programs 
date: 2015-06-01T16:00+0200
---

# Books that changed my career - Structure and Interpretation of Computer Programs

<quote class="disclaimer">This blog post is another one in the series which contains the most influential books that I have read in my programming career. This is my private ranking, each post contains a good dose of my private opinions (you have been warned :wink:), but besides that I hope that you will find it valuable.</quote>

### Introduction

<img class="right sicp-logo" alt="Structure and Interpretation of Computer Programs - Cover" src="/assets/SICPCover.jpg" />

Only a few books have such significant impact on the *computer science* and IT environment as the book mentioned in the title. Obviously, this is very personal choice - but some of them are universally equal for all of us. One of such books we have described previously - I am talking about *Pragmatic Programmer*, which is the most known and valuable book for aspiring programmer and a *craftsman*. But let's talk about the book which is a foundation for the whole course on *MIT*. And I hope that I do not have to remind you *what* and *how important* for *computer science* MIT is.

Let's start with this long quote from one of the unquestionable (or questionable - in this case, doesn't matter, because citation is really accurate) authorities in IT world - [@unclebobmartin](https://twitter.com/unclebobmartin):

<p>
  <quote class="citation">SICP is a literary masterpiece. It's not often that you can say that a technical book is a page-turner, but that's just what I found SICP to be.  The book moves from topic to topic with rare ease and clarity, but more importantly it moves with purpose and mission.  As you read it, you can feel the authors slowly building a tension towards a climax. The chapters fly by as you read about data structures, algorithms, message passing, first-class procedures, and so much else. Each concept leads inevitably to the next. Each chapter adds to the ever building tension. By time you are half-way through the book, the sense that something important is about to change becomes palpable.</quote>
</p>
<p>
<quote class="citation">And then something important changes! Something you had not anticipated. Something you should have guessed, but did not. On page 216 they introduce a concept so familiar that most programming books start with it. On page 216 they prove to you that you've had some wrong ideas about programming all along. On page two hundred and sixteen, after talking about algorithms, data structures, recursion, iteration, trees, high-order procedures, scoping, local variables, data abstraction, closures, message-passing, and a plethora of other topics - after all that, they introduce assignment!</quote>
</p>
<p>
  <quote class="citation">And with that elegant coup-de-grace (which is not the last in this book!), they vanquish the concept that programming is about manipulating state. With that one stroke, they force you to look back on all you had done in the previous pages in a new and enlightened way - a functional way.</quote>
</p>

If you have not been exposed to *functional programming* earlier those statements will sound to you at least ground breaking, if not ridiculous. Moreover, if you are starting your career as a programmer, immediately grab this book and start reading it - it will be beneficial for you, you will open your mind to a different paradigm. Moreover, you will not have so much *mental baggage* to unlearn, as the most programmers exposed to *object-oriented programming languages* (which are in most cases [implemented in a wrong way](http://c2.com/cgi/wiki?AlanKaysDefinitionOfObjectOriented)).

### Ok, I am in. How to read it?

I am reading this book second time in my life, and I am trying to do it mindfully, with full focus (it is really hard, but I am trying :wink:). I also play with plethora of assignments gathered at the end of each chapter - each time I am fiddling with them in different programming language. I would like to preserve knowledge from the reading process, and I would like to introduce you to the next blog post series which will start at 4th of June.

How it will look like? Often people are getting this book as a topic of the local reading club (second book which is often used as a topic is a [Little Schemer](http://mitpress.mit.edu/books/little-schemer)). I have not found one around, so I will do it by myself. I will sum up each chapter with a post, adding also small examples and topics that I found interesting related to that chapter. Thanks to that, I and maybe someone else can return to this place and recall interesting bits easier.

I hope that you will enjoy new series. Give me your feelings about that and feedback in the comments - and let's stay in touch till Thursday! :smile: 

### What's next?

Obviously, this post cannot end the whole series about important books for my career. Next time, I will present a book which has a special place on my bookshelf, because it changed drastically my thinking about concurrency. Moreover, it is already extensively quoted on this blog. Also, it has very nice drawings and *IMHO* is a great continuation of the original idea. Author of this book is a well known programmer in the *Erlang* world. And probably, by that statement, you should be pretty sure which book I described here. So, see you soon! :wink:

### Credits

- [Why Clojure?](http://thecleancoder.blogspot.com/2010/08/why-clojure.html) by [@unclebobmartin](https://twitter.com/unclebobmartin)
- [Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/books/structure-and-interpretation-computer-programs), *Harold Abelson*, *Gerald Jay Sussman* and *Julie Sussman*
- [Full book available online](https://mitpress.mit.edu/sicp/full-text/book/book.html)
