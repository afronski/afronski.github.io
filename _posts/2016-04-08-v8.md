---
layout: post
title: A mythical beast called JIT
date: 2016-04-08T18:00+0200
tags:
  - v8
  - javascript
  - node.js
  - jit
---

# A mythical beast called `JIT`

I have recently bumped into one of those articles which title sounds rather like ["one weird trick"](https://top.fse.guru/nodejs-a-quick-optimization-advice-7353b820c92e) ad. Guiding just from it, you can imagine how small amount of information is contained there, and by actually going through that link there you will definitely make sure that it has even less amount of information there.

Of course, a final explanation is indeed really simple - `Function.prototype.toString()` returns everything even the comments inside the function body, size of that string is a feature that allows the optimizing compiler inside *V8* to make a decision to inline that particular function or not. There is even a command line switch which to use to modify a limit and a default value. Simple enough? Not really.

That article left a lot of unanswered questions. Probably because of that *JIT* compilers and its optimization techniques are kind of black magic.

## Why is it hard?

Obviously compiler engineers are not dumb people (they are actually really smart) and they are not obfuscating and complicating this by accident or on purpose. They are working hard, especially with such weakly typed and underspecified languages like *JavaScript* to provide you an optimized version of your code. Why is it a hard job? *It is all about guarantees*.

How many of them you can recall from memory in *JavaScript*? Not a lot of them, right? That is not good, especially from the perspective of compiler engineer. Nowadays *JavaScript* is everywhere, success of internet pushed this language from front-end, even to server-side - and everywhere people are talking about performance. Obviously not about native like performance for scientific computations, but the more complexity is pushed to the application logic the more of it will have to be optimized after all.

Returning to the main topic, one of many tricks that they are using, which is used also in that case is called *compilation cache*.

## V8 and compilation cache optimization

It is a really simple trick, where compiler textually compares the implementation of the function and if it is the same as the other ones, replaces its invocation by a cached and previously optimized version. Why? Because if optimization is a hard process, so why compiler should do it many times for the same code sample? If we can avoid it, we can speed-up the execution even more.

There are two culprits related to that - one is that using particular language features which are considered as unsafe (e.g. like `with` in *JavaScript*) causes optimizing compiler to *bailout* and erases all optimizations to that part of code - also to the previously optimized version, which as you can imagine is really expensive. Second thing is related with the *textual representation*, often compilers are not working directly on the source code level, but first they are transforming it and they are making series of considered as safe modifications that are speed-up and cleaning up code (e.g. by removing unused parts).

But that's not the case inside *Cranshaft* (a *V8* optimizing compiler). There is one additional trick that we can use, that is really well described by one of my favorite presenters and compiler evangelists *Vyacheslav Egorov* - he is using *UUIDs* hard-coded inside a comment in the function body to distinguish logically different functions, that will be potentially compiled and inlined from a single cache entry.

Why he would like to avoid that? In order to minimize the cache misses, when we're generating code or do other fancy stuff, that you should be aware of if you are doing that in the first place. Yeah, *JIT* and compilation techniques are *hard*.

## Credits

- [Node.js: A quick optimization advice](https://top.fse.guru/nodejs-a-quick-optimization-advice-7353b820c92e)
- [Vyacheslav Egorov: invokedynamic.js - JSConf EU 2014](https://youtu.be/YOHBZactXus?t=515)
- [Brilliant checklist for optimization in Node.js](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html)
