<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <meta name="author" content="Wojtek Gawroński (afronski)" />
    <meta name="description" content="Personal blog of Wojtek Gawroński, a passionate software developer." />

    <meta name="keywords" content="HTML,HTML5,JavaScript,CSS,CSS3,Canvas,WebGL,C#,.NET,Mono,Erlang,Vagrant,Node.js,Clojure,SICP" />

    <meta name="viewport" content="width=device-width" />

    <link rel="alternate" type="application/rss+xml" title="afronski.pl" href="http://www.afronski.pl/feed.xml" />

    <title>SICP in Clojure - Chapter 4</title>

    <link rel="stylesheet" href="/stylesheets/syntax.min.css" />
    <link rel="stylesheet" href="/stylesheets/main.css" />
  </head>
  <body>
    <section class="ads">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9524821705718873" data-ad-slot="3234654745" data-ad-format="auto"></ins>
      <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>
    </section>

    <article class="container post">
      <a href="/">Home</a>

<h1 id="sicp-in-clojure---chapter-4">SICP in Clojure - Chapter 4</h1>

<quote class="disclaimer">In one of the <a href="http://www.afronski.pl/books-that-changed-my-career/2015/06/01/books-that-changed-my-career-structure-and-interpretation-of-computer-programs.html">previous blog posts</a> I have announced that I would like to start a new series of posts. It is a persistent journal from my journey through aforementioned book. I hope that you will enjoy it and find it useful - the main goal is to make this series a place where we can return in future, recall ideas and thoughts that accompanied reading process.</quote>

<h3 id="introduction">Introduction</h3>

<p>By finishing the <a href="http://www.afronski.pl/sicp-in-clojure/2015/09/18/sicp-in-clojure-chapter-3.html">previous chapter</a> we learned more about <em>functional programming</em>, <em>designing</em> and <em>dealing</em> with stateful computation and a little bit about <em>laziness</em>. It was pretty much a <em>general purpose programming book</em> till now. Last two chapters of the book are really … <em>Lispy</em>. <img class="emoji" title=":wink:" alt=":wink:" src="https://assets.github.com/images/icons/emoji/unicode/1f609.png" height="20" width="20" align="absmiddle" /></p>

<p>Chapter which will be discussed today is focused on <em>Lisp</em> core values built around <em>universal evaluator</em>, <em>homoiconicity</em> and <em>linguistic abstractions</em>.</p>

<h3 id="what-is-homoiconicity">What is homoiconicity?</h3>

<p>Very concise, I would say a <em>mathematical</em>, definition will explain it as a isomorphic relation between language <em>AST</em> (<em>Abstract Syntax Tree</em>) and its syntax. In more human friendly words - it is a property of a programming language in which the program structure is similar to its syntax. If such language is <em>homoiconic</em>, it allows all code in the language to be accessed and transformed as data, using the same representation - because <em>AST</em> is exactly the same as the language itself.</p>

<p>All languages from <em>Lisp</em> family have this property, also languages like <a href="http://www.afronski.pl/7-languages-in-7-weeks/2015/04/30/seven-languages-in-seven-weeks-io.html"><em>Io</em></a>, <em>Julia</em> or <a href="http://www.afronski.pl/7-languages-in-7-weeks/2015/05/24/seven-languages-in-seven-weeks-prolog.html"><em>Prolog</em></a> also have this ability (to a certain degree of course). Keep in mind that it does not mean that having a <em>macros system</em> in the language makes it <em>homoiconic</em>.</p>

<h3 id="metalinguistic-abstraction">Metalinguistic abstraction</h3>

<p>Title of this section sounds like a difficult concept, where the core idea is really simple. Aforementioned abstraction is an ability to <em>create new languages</em>. We have done that previously (e.g. by creating various <em>Domain Specific Languages</em> when solving exercises). By the creation, authors also mean ability to <em>evaluate</em> (or <em>interpret</em>) constructs written in that newly created dialect, by calculating values from the prepared expressions. Program which does such thing is called <em>an evaluator</em> (or <em>interpreter</em>).</p>

<p>If we go one level deeper in the abstraction tree, a <em>metacircular evaluator</em> (or also often called a <em>metacircular interpreter</em>) is an evaluator written in the same language that it will interpret. It means that you can write an interpreter of any <em>Lisp</em> dialect in that chosen language.</p>

<h3 id="core-of-metacircular-evaluator">Core of metacircular evaluator</h3>

<p><em>Clojure</em> REPL (actually any kind of <em>REPL</em>) is an <em>evaluator</em>. But also, our run-time environments are also built on top of such constructs.</p>

<p>In <em>Lisp</em>, the core of the evaluator is often called an <code>eval</code>-<code>apply</code> cycle. If we will dive into implementations presented in the book, we will immediately see a symmetry between them. Authors defined both of them as follows.</p>

<h4 id="eval"><code>eval</code></h4>

<quote class="citation">
  To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions.
</quote>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno">1</span> <span class="c1">;; You can either evaluate quoted expressions</span>
<span class="lineno">2</span> <span class="c1">;; or strings, but keep in mind that string</span>
<span class="lineno">3</span> <span class="c1">;; does not have an AST-like structure by itself.</span>
<span class="lineno">4</span> <span class="c1">;; It needs to be parsed first (with a</span>
<span class="lineno">5</span> <span class="c1">;; `read-string`).</span>
<span class="lineno">6</span> 
<span class="lineno">7</span> <span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="mi">10</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span> <span class="nv">a</span><span class="p">)))</span>
<span class="lineno">8</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">read-string</span> <span class="s">&quot;(+ 1 1)&quot;</span><span class="p">))</span></code></pre></div>

<p>Evaluation means that we take fragment of the code (in form of a <em>quoted expression</em> or parsed from a string) and evaluate that, using all rules of the language. In other words, it <em>calculates</em> the result of a certain expression. Keep in mind that a delivered expression is just a data structure - list of keywords, other tokens, and other data structures. <strong>And it looks exactly the same as the language itself</strong>. That is a practical implication of the homoiconicity.</p>

<h4 id="apply"><code>apply</code></h4>

<quote class="citation">
  To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment. To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied.
</quote>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="c1">;; Result of executing both expressions is</span>
<span class="lineno"> 2</span> <span class="c1">;; exactly the same, but only the first one</span>
<span class="lineno"> 3</span> <span class="c1">;; is an application.</span>
<span class="lineno"> 4</span> <span class="c1">;;</span>
<span class="lineno"> 5</span> <span class="c1">;; Function application means that you have to</span>
<span class="lineno"> 6</span> <span class="c1">;; deliver all arguments upfront in a form of</span>
<span class="lineno"> 7</span> <span class="c1">;; collection.</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="p">(</span><span class="nb">apply str </span><span class="p">[</span><span class="s">&quot;str1&quot;</span> <span class="s">&quot;str2&quot;</span> <span class="s">&quot;str3&quot;</span><span class="p">])</span>
<span class="lineno">10</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;str1&quot;</span> <span class="s">&quot;str2&quot;</span> <span class="s">&quot;str3&quot;</span><span class="p">)</span></code></pre></div>

<p>At the first sight you will find that <code>apply</code> is only a strange syntax for a function invocation. But then, the obvious reflection strikes in - <strong>it is exactly the opposite</strong>. Function call is a syntax sugar on top of <code>apply</code> function. Moreover, having this function in your toolbox opens a different ways of thinking about invoking unknown functions, and build other concepts like <em>partial application</em> and <em>currying</em> based on that.</p>

<h4 id="combining-both-powers-together">Combining both powers together</h4>

<p>Process of interpreting a program is an interaction between them. How it looks like? Here is an excerpt from an implementation (again full version is inside my repository - <a href="https://github.com/afronski/sicp-examples/blob/master/chapters/4/4.1.1/eval-apply.clj">afronski/sicp-in-examples</a>):</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">my-eval</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">env</span><span class="p">]</span>
<span class="lineno"> 2</span>   <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">self-evaluating?</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">exp</span>
<span class="lineno"> 3</span>         <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span>        <span class="p">(</span><span class="nf">lookup-variable-value</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno"> 4</span>         <span class="p">(</span><span class="nf">quoted?</span> <span class="nv">exp</span><span class="p">)</span>          <span class="p">(</span><span class="nf">text-of-quotation</span> <span class="nv">exp</span><span class="p">)</span>
<span class="lineno"> 5</span>         <span class="p">(</span><span class="nf">assignment?</span> <span class="nv">exp</span><span class="p">)</span>      <span class="p">(</span><span class="nf">my-eval-assignment</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno"> 6</span>         <span class="p">(</span><span class="nf">definition?</span> <span class="nv">exp</span><span class="p">)</span>      <span class="p">(</span><span class="nf">my-eval-definition</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno"> 7</span>         <span class="p">(</span><span class="nf">if?</span> <span class="nv">exp</span><span class="p">)</span>              <span class="p">(</span><span class="nf">my-eval-if</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno"> 8</span>         <span class="p">(</span><span class="nf">lambda?</span> <span class="nv">exp</span><span class="p">)</span>          <span class="p">(</span><span class="nf">make-procedure</span> <span class="p">(</span><span class="nf">lambda-parameters</span> <span class="nv">exp</span><span class="p">)</span>
<span class="lineno"> 9</span>                                                <span class="p">(</span><span class="nf">lambda-body</span> <span class="nv">exp</span><span class="p">)</span>
<span class="lineno">10</span>                                                <span class="nv">env</span><span class="p">)</span>
<span class="lineno">11</span>         <span class="p">(</span><span class="nf">do?</span> <span class="nv">exp</span><span class="p">)</span>              <span class="p">(</span><span class="nf">my-eval-sequence</span> <span class="p">(</span><span class="nf">do-actions</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno">12</span>         <span class="p">(</span><span class="nf">cond?</span> <span class="nv">exp</span><span class="p">)</span>            <span class="p">(</span><span class="nf">my-eval</span> <span class="p">(</span><span class="nf">cond-&gt;if</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno">13</span>         <span class="p">(</span><span class="nf">application?</span> <span class="nv">exp</span><span class="p">)</span>     <span class="p">(</span><span class="nf">my-apply</span> <span class="p">(</span><span class="nf">my-eval</span> <span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
<span class="lineno">14</span>                                          <span class="p">(</span><span class="nf">list-of-values</span> <span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">))</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>         <span class="ss">:else</span>                  <span class="p">(</span><span class="nb">assert </span><span class="nv">false</span> <span class="s">&quot;Unknown expression in `my-eval`.&quot;</span><span class="p">)))</span>
<span class="lineno">17</span> 
<span class="lineno">18</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">my-apply</span> <span class="p">[</span><span class="nv">proc</span> <span class="nv">args</span><span class="p">]</span>
<span class="lineno">19</span>   <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">primitive-procedure?</span> <span class="nv">proc</span><span class="p">)</span>
<span class="lineno">20</span>           <span class="p">(</span><span class="nf">my-apply-primitive-procedure</span> <span class="nv">proc</span> <span class="nv">args</span><span class="p">)</span>
<span class="lineno">21</span>         <span class="p">(</span><span class="nf">compound-procedure?</span> <span class="nv">proc</span><span class="p">)</span>
<span class="lineno">22</span>           <span class="p">(</span><span class="nf">my-eval-sequence</span> <span class="p">(</span><span class="nf">procedure-body</span> <span class="nv">proc</span><span class="p">)</span>
<span class="lineno">23</span>                             <span class="p">(</span><span class="nf">extend-environment</span> <span class="p">(</span><span class="nf">procedure-parameters</span> <span class="nv">proc</span><span class="p">))</span>
<span class="lineno">24</span>                             <span class="nv">args</span>
<span class="lineno">25</span>                             <span class="p">(</span><span class="nf">procedure-environment</span> <span class="nv">proc</span><span class="p">))</span>
<span class="lineno">26</span> 
<span class="lineno">27</span>         <span class="ss">:else</span>
<span class="lineno">28</span>           <span class="p">(</span><span class="nb">assert </span><span class="nv">false</span> <span class="s">&quot;Unknown procedure type in `my-apply`.&quot;</span><span class="p">)))</span></code></pre></div>

<p>Even without exact definitions of the used functions, code is pretty self-explanatory. As we can see <em>evaluation</em> requires in certain cases an <em>application</em>, and <em>application</em> requires <em>evaluation</em> of function <em>body</em> and <em>arguments</em>. They are often expressed as a <em>yin-yang</em> symbol, because they are complementing each other.</p>

<h3 id="different-evaluation-models">Different evaluation models</h3>

<p>Instead of <em>reimplementing</em> different evaluation models, I have prepared different examples of such, built on top of <em>Clojure</em> standard library (or sometimes with additional custom facilities). We will start with the concept which we already know from the previous chapter.</p>

<h4 id="laziness">Laziness</h4>

<p>We have met this concept earlier already. In the previous chapter we worked with <em>streams</em> and infinite collections which simulate e.g. computation process. But built-in mechanisms in <em>Clojure</em> have much more to offer in that matter. We have already created some infinite collections, but let us remind how it works:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="p">(</span><span class="nb">import </span><span class="nv">java.util.UUID</span><span class="p">)</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">uuid-seq</span> <span class="p">[]</span>
<span class="lineno"> 4</span>   <span class="p">(</span><span class="nf">lazy-seq</span>
<span class="lineno"> 5</span>     <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">))</span>
<span class="lineno"> 6</span>           <span class="p">(</span><span class="nf">uuid-seq</span><span class="p">))))</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">uuid-seq</span><span class="p">)))</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="c1">; (b09b2a29-2cad-4cda-8e4c-8a9a5c136f05</span>
<span class="lineno">11</span> <span class="c1">;  8ece35e6-202f-4977-9987-7292239833e4</span>
<span class="lineno">12</span> <span class="c1">;  0a336e55-5e42-4312-87ea-24e86ba4311e)</span></code></pre></div>

<p>First we are defining a <code>lazy-seq</code> then we use standard mechanism of constructing the collection from the first, <em>evaluated</em> element and the rest, which evaluation will be deferred. What I mean by deferring? If you will try to put the following lines inside a file (but not inside the <em>REPL</em> - it will force the evaluation) you will receive nothing:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="c1">; This returns a lazy collection, which</span>
<span class="lineno"> 2</span> <span class="c1">; is not evaluated yet.</span>
<span class="lineno"> 3</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="c1">; You can force evaluation either by</span>
<span class="lineno"> 6</span> <span class="c1">; enforcing simple run (and wait for</span>
<span class="lineno"> 7</span> <span class="c1">; side-effects) or return the result</span>
<span class="lineno"> 8</span> <span class="c1">; of the operation.</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="p">(</span><span class="nb">dorun </span><span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]))</span> <span class="c1">; nil</span>
<span class="lineno">11</span> <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]))</span> <span class="c1">; (2 3 4 5)</span></code></pre></div>

<p>But it is not an only way of creating lazy sequences. You can use also <code>repeat</code>, <code>repeatedly</code>, <code>cycle</code> or <code>iterate</code> in a following way:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="c1">; `repeat` and `repeatedly` creates an infinite sequence</span>
<span class="lineno"> 2</span> <span class="c1">; either of elements or results of a function call. You can</span>
<span class="lineno"> 3</span> <span class="c1">; create infinite sequence or a limited one by passing an</span>
<span class="lineno"> 4</span> <span class="c1">; argument or not.</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">clojure.string/join</span> <span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="p">(</span><span class="nb">repeat </span><span class="s">&quot;Na &quot;</span><span class="p">)))</span> <span class="s">&quot;Batman!&quot;</span><span class="p">))</span>
<span class="lineno"> 7</span>   <span class="c1">; &quot;Na Na Na Na Na Batman!&quot;</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">5</span> <span class="o">#</span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">100</span><span class="p">)))</span>
<span class="lineno">10</span>   <span class="c1">; 34 23 12 1 23</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="c1">; `cycle` returns a lazy collection with repetitions</span>
<span class="lineno">13</span> <span class="c1">; of a delivered collection.</span>
<span class="lineno">14</span> 
<span class="lineno">15</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="p">(</span><span class="nb">cycle </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])))</span>
<span class="lineno">16</span>   <span class="c1">; (1 2 3 1 2)</span>
<span class="lineno">17</span> 
<span class="lineno">18</span> <span class="c1">; `iterate` is a more generic constructor. It returns</span>
<span class="lineno">19</span> <span class="c1">; a lazy sequence, which has the following values:</span>
<span class="lineno">20</span> <span class="c1">;</span>
<span class="lineno">21</span> <span class="c1">;   x, f(x), f(f(x)), ...</span>
<span class="lineno">22</span> <span class="c1">;</span>
<span class="lineno">23</span> <span class="c1">; This also means, that used `f` functions should be</span>
<span class="lineno">24</span> <span class="c1">; *pure* (no side-effects).</span>
<span class="lineno">25</span> 
<span class="lineno">26</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="p">(</span><span class="nb">iterate </span><span class="p">(</span><span class="nb">partial * </span><span class="mi">3</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
<span class="lineno">27</span>   <span class="c1">; (1 3 9 27 81)</span></code></pre></div>

<p>But laziness can be also used in a different way.</p>

<h4 id="ambiguous-operator">Ambiguous operator</h4>

<p>Around 1961, John McCarthy (the inventor of LISP) described an interesting mathematical operator called <code>amb</code> (from <em>ambiguous</em>). Essentially, <code>amb</code> have to be called with arguments, but thanks to that - it can look into the future to <em>keep that from happening</em>. It does that by <em>rewinding</em> into the past whenever it sees trouble, and try a different choice.</p>

<p>It is called a <a href="https://en.wikipedia.org/wiki/Backtracking"><em>backtracking algorithm</em></a>. This technique is often used for solving problems with huge search space. The most canonical example is called <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle"><em>8 queens puzzle</em></a>. Whole approach is partially based on top of <em>laziness</em> and searching problem space in a lazy way, basing on the constraints and then doing a <em>backtracking</em>.</p>

<p>In example presented below, we are trying to find all <em>Pythagorean triple</em> solutions in a specific range, passed as an argument:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="c1">; Both `amb-let` and `amb-let-helper` implementations</span>
<span class="lineno"> 2</span> <span class="c1">; are shamelessly taken from:</span>
<span class="lineno"> 3</span> <span class="c1">;   https://github.com/abeppu/toychest</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">amb-let-helper</span> <span class="p">[</span><span class="nv">bindings</span> <span class="nv">body</span><span class="p">]</span>
<span class="lineno"> 6</span>   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="mi">0</span> <span class="p">(</span><span class="nb">count </span><span class="nv">bindings</span><span class="p">))</span>
<span class="lineno"> 7</span>     <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">form</span> <span class="nv">expression</span><span class="p">]</span> <span class="p">(</span><span class="nb">take </span><span class="mi">2</span> <span class="nv">bindings</span><span class="p">)</span>
<span class="lineno"> 8</span>           <span class="nv">more-bindings</span> <span class="p">(</span><span class="nb">drop </span><span class="mi">2</span> <span class="nv">bindings</span><span class="p">)</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span>           <span class="nv">filtered-recurse</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="ss">:where</span> <span class="p">(</span><span class="nb">first </span><span class="nv">more-bindings</span><span class="p">))</span>
<span class="lineno">11</span>                              <span class="o">`</span><span class="p">(</span><span class="nb">when </span><span class="o">~</span><span class="p">(</span><span class="nb">second </span><span class="nv">more-bindings</span><span class="p">)</span>
<span class="lineno">12</span>                                 <span class="o">~</span><span class="p">(</span><span class="nf">amb-let-helper</span> <span class="p">(</span><span class="nb">drop </span><span class="mi">2</span> <span class="nv">more-bindings</span><span class="p">)</span> <span class="nv">body</span><span class="p">))</span>
<span class="lineno">13</span>                              <span class="p">(</span><span class="nf">amb-let-helper</span> <span class="nv">more-bindings</span> <span class="nv">body</span><span class="p">))</span>
<span class="lineno">14</span> 
<span class="lineno">15</span>           <span class="nv">res</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">seq? </span><span class="nv">expression</span><span class="p">)</span>
<span class="lineno">16</span>                        <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;amb</span> <span class="p">(</span><span class="nb">first </span><span class="nv">expression</span><span class="p">)))</span>
<span class="lineno">17</span>                 <span class="o">`</span><span class="p">(</span><span class="nb">apply concat </span><span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="o">~</span><span class="nv">form</span> <span class="o">~</span><span class="p">(</span><span class="nb">second </span><span class="nv">expression</span><span class="p">)]</span>
<span class="lineno">18</span>                                  <span class="o">~</span><span class="nv">filtered-recurse</span><span class="p">))</span>
<span class="lineno">19</span>                 <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">~</span><span class="nv">form</span> <span class="o">~</span><span class="nv">expression</span><span class="p">]</span>
<span class="lineno">20</span>                    <span class="o">~</span><span class="nv">filtered-recurse</span><span class="p">))]</span>
<span class="lineno">21</span>       <span class="nv">res</span><span class="p">)</span>
<span class="lineno">22</span>     <span class="p">[</span><span class="nv">body</span><span class="p">]))</span>
<span class="lineno">23</span> 
<span class="lineno">24</span> <span class="c1">; Macro definition.</span>
<span class="lineno">25</span> 
<span class="lineno">26</span> <span class="p">(</span><span class="kd">defmacro </span><span class="nv">amb-let</span> <span class="p">[</span><span class="nv">bindings</span> <span class="nv">body</span><span class="p">]</span>
<span class="lineno">27</span>   <span class="p">(</span><span class="nf">amb-let-helper</span> <span class="nv">bindings</span> <span class="nv">body</span><span class="p">))</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> <span class="c1">; Defining problem and its constraints.</span>
<span class="lineno">30</span> <span class="c1">; We would like to calculate all triples in range 100 that</span>
<span class="lineno">31</span> <span class="c1">; fullfilling following conditions:</span>
<span class="lineno">32</span> <span class="c1">;</span>
<span class="lineno">33</span> <span class="c1">;   2 &lt; a &lt; MAX</span>
<span class="lineno">34</span> <span class="c1">;   a &lt;= b &lt; MAX</span>
<span class="lineno">35</span> <span class="c1">;   b &lt;= c &lt; MAX</span>
<span class="lineno">36</span> <span class="c1">;</span>
<span class="lineno">37</span> <span class="c1">;   a^2 + b^2 = c^2</span>
<span class="lineno">38</span> 
<span class="lineno">39</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">triple</span> <span class="p">[</span><span class="nv">max</span><span class="p">]</span>
<span class="lineno">40</span>   <span class="p">(</span><span class="nf">amb-let</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">amb</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="nv">max</span><span class="p">))</span> <span class="ss">:where</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span>
<span class="lineno">41</span>             <span class="nv">b</span> <span class="p">(</span><span class="nf">amb</span> <span class="p">(</span><span class="nb">range </span><span class="nv">a</span> <span class="nv">max</span><span class="p">))</span>
<span class="lineno">42</span>             <span class="nv">c</span> <span class="p">(</span><span class="nf">amb</span> <span class="p">(</span><span class="nb">range </span><span class="nv">b</span> <span class="nv">max</span><span class="p">))</span>
<span class="lineno">43</span> 
<span class="lineno">44</span>             <span class="ss">:where</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">b</span><span class="p">))</span>
<span class="lineno">45</span>                       <span class="p">(</span><span class="nb">* </span><span class="nv">c</span> <span class="nv">c</span><span class="p">))]</span>
<span class="lineno">46</span>            <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]))</span>
<span class="lineno">47</span> 
<span class="lineno">48</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">triple</span> <span class="mi">20</span><span class="p">))</span>
<span class="lineno">49</span> <span class="c1">;  ([3 4 5] [5 12 13] [6 8 10] [8 15 17] [9 12 15])</span></code></pre></div>

<p>Talking about <em>backtracking</em>, we can again building on top of that concept power our next <em>evaluator extension</em>. We can use it for <em>logic programming</em> and it is described in the book as a last enhancement.</p>

<h4 id="logic-programming">Logic programming</h4>

<p>Book takes that concept as a last one, by implementing own version of <em>logic</em> engine in the <em>Scheme</em>. In <em>Clojure</em> and <em>ClojureScript</em> there is no point of doing that, because we have it in the set of additional libraries. It is called <code>core.logic</code> and it is delivered as a separate <a href="https://github.com/clojure/core.logic">library</a>.</p>

<p>In prepared example we will take the most common problem when it comes to the <em>logic programming kindergarten</em> - simple genealogy questions. It may sound simple, but the provided <em>relations</em>, <em>facts</em> and <em>queries</em> will show the basic unification mechanism:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="lineno"> 1</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">logic-example.core</span>
<span class="lineno"> 2</span>   <span class="p">(</span><span class="ss">:use</span> <span class="p">[</span><span class="nv">clojure.core.logic.pldb</span><span class="p">]))</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="c1">; In the logic programming we are creating *relations* and *facts*.</span>
<span class="lineno"> 5</span> <span class="c1">; Relation describes how to interpret *facts*, with certain associations.</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="p">(</span><span class="nf">db-rel</span> <span class="nv">father</span> <span class="nv">Father</span> <span class="nv">Child</span><span class="p">)</span>
<span class="lineno"> 8</span> <span class="p">(</span><span class="nf">db-rel</span> <span class="nv">mother</span> <span class="nv">Mother</span> <span class="nv">Child</span><span class="p">)</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="c1">; *Facts* are the truths, nothing more than a specific data structure</span>
<span class="lineno">11</span> <span class="c1">; which describes our state of knowledge.</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="p">(</span><span class="k">def </span><span class="nv">genealogy</span>
<span class="lineno">14</span>   <span class="p">(</span><span class="nf">db</span>
<span class="lineno">15</span>    <span class="p">[</span><span class="nv">father</span> <span class="ss">&#39;Adam</span> <span class="ss">&#39;Wiliam</span><span class="p">]</span>
<span class="lineno">16</span>    <span class="p">[</span><span class="nv">father</span> <span class="ss">&#39;Adam</span> <span class="ss">&#39;Thomas</span><span class="p">]</span>
<span class="lineno">17</span>    <span class="p">[</span><span class="nv">father</span> <span class="ss">&#39;Andrew</span> <span class="ss">&#39;Jessica</span><span class="p">]</span>
<span class="lineno">18</span>    <span class="p">[</span><span class="nv">father</span> <span class="ss">&#39;Andrew</span> <span class="ss">&#39;Mark</span><span class="p">]</span>
<span class="lineno">19</span>    <span class="c1">; We are deliberately omitting Dorothy&#39;s father here.</span>
<span class="lineno">20</span> 
<span class="lineno">21</span>    <span class="p">[</span><span class="nv">mother</span> <span class="ss">&#39;Eve</span> <span class="ss">&#39;Wiliam</span><span class="p">]</span>
<span class="lineno">22</span>    <span class="p">[</span><span class="nv">mother</span> <span class="ss">&#39;Eve</span> <span class="ss">&#39;Thomas</span><span class="p">]</span>
<span class="lineno">23</span>    <span class="p">[</span><span class="nv">mother</span> <span class="ss">&#39;Eve</span> <span class="ss">&#39;Jessica</span><span class="p">]</span>
<span class="lineno">24</span>    <span class="p">[</span><span class="nv">mother</span> <span class="ss">&#39;Angie</span> <span class="ss">&#39;Mark</span><span class="p">]</span>
<span class="lineno">25</span>    <span class="p">[</span><span class="nv">mother</span> <span class="ss">&#39;Angie</span> <span class="ss">&#39;Dorothy</span><span class="p">]))</span>
<span class="lineno">26</span> 
<span class="lineno">27</span> <span class="c1">; Having *facts* and *relations* we can query them and thanks to them</span>
<span class="lineno">28</span> <span class="c1">; `unification` mechanism, based on defined relations and facts available</span>
<span class="lineno">29</span> <span class="c1">; in the database our logic engine will answer to that query with one,</span>
<span class="lineno">30</span> <span class="c1">; more or no results.</span>
<span class="lineno">31</span> 
<span class="lineno">32</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">jessica-mother</span><span class="p">[]</span>
<span class="lineno">33</span>   <span class="p">(</span><span class="nf">with-db</span> <span class="nv">genealogy</span>
<span class="lineno">34</span>     <span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
<span class="lineno">35</span>       <span class="p">(</span><span class="nf">mother</span> <span class="nv">q</span> <span class="ss">&#39;Jessica</span><span class="p">))))</span>
<span class="lineno">36</span> 
<span class="lineno">37</span> <span class="c1">; user=&gt; (logic-example.core/jessica-mother)</span>
<span class="lineno">38</span> <span class="c1">; (Eve)</span>
<span class="lineno">39</span> 
<span class="lineno">40</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">adam-children</span> <span class="p">[]</span>
<span class="lineno">41</span>   <span class="p">(</span><span class="nf">with-db</span> <span class="nv">genealogy</span>
<span class="lineno">42</span>       <span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
<span class="lineno">43</span>         <span class="p">(</span><span class="nf">father</span> <span class="ss">&#39;Adam</span> <span class="nv">q</span><span class="p">))))</span>
<span class="lineno">44</span> 
<span class="lineno">45</span> <span class="c1">; user=&gt; (logic-example.core/dorothy-father)</span>
<span class="lineno">46</span> <span class="c1">; (Thomas Wiliam)</span>
<span class="lineno">47</span> 
<span class="lineno">48</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">dorothy-father</span> <span class="p">[]</span>
<span class="lineno">49</span>   <span class="p">(</span><span class="nf">with-db</span> <span class="nv">genealogy</span>
<span class="lineno">50</span>     <span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
<span class="lineno">51</span>       <span class="p">(</span><span class="nf">father</span> <span class="nv">q</span> <span class="ss">&#39;Dorothy</span><span class="p">))))</span>
<span class="lineno">52</span> 
<span class="lineno">53</span> <span class="c1">; user=&gt; (logic-example.core/dorothy-father)</span>
<span class="lineno">54</span> <span class="c1">; ()</span></code></pre></div>

<p>Depending on the knowledge and the environment, answers to the prepared questions are different. Query can return either one, more or no results. Everything is related with previously defined <em>facts</em> and <em>relations</em>. It looks pretty amazing, and that is only an introduction to that topic. For more, I will recommend you to read either about <em>Prolog</em> (you can start from <a href="http://www.afronski.pl/7-languages-in-7-weeks/2015/05/24/seven-languages-in-seven-weeks-prolog.html">here</a>) or play with this <a href="https://github.com/swannodette/logic-tutorial">tutorial</a>.</p>

<h3 id="summary">Summary</h3>

<p>We have managed to finish 4th chapter of the book. In the last part we will attack problems with which we are already familiar, but on the lowest possible level. We will focus on hardware specifics of <em>Lisp</em> evaluator implementations, including design constraints and limitations related with those topics.</p>

<p>I hope that we will meet there again! <img class="emoji" title=":smile:" alt=":smile:" src="https://assets.github.com/images/icons/emoji/unicode/1f604.png" height="20" width="20" align="absmiddle" /></p>

<h3 id="credits">Credits</h3>

<ul>
  <li><a href="http://mitpress.mit.edu/books/structure-and-interpretation-computer-programs">Structure and Interpretation of Computer Programs</a>, <em>Harold Abelson</em>, <em>Gerald Jay Sussman</em> and <em>Julie Sussman</em></li>
  <li><a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">Full book available online</a></li>
  <li><a href="https://github.com/afronski/sicp-examples">afronski/sicp-examples</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Homoiconicity">Homoiconicity</a></li>
</ul>

    </article>

    <section class="container">
      <a href="/" class="mobile-link">Home</a>

      <section class="social-buttons">
        <div class="fb-share-button" data-href="/sicp-in-clojure/2015/10/05/sicp-in-clojure-chapter-4.html" data-layout="button_count"></div>
        <script type="IN/Share" data-url="/sicp-in-clojure/2015/10/05/sicp-in-clojure-chapter-4.html" data-counter="right"></script>
        <a href="https://twitter.com/share" class="twitter-share-button" data-text="Nice blog post:" data-via="afronski">Tweet</a>
      </section>

      <div id="disqus_thread"></div>
    </section>

    <aside class="menu">

      <a href="http://www.afronski.pl">
        <img id="avatar" src="/images/avatar.png" alt="My avatar" />
      </a>

      Hello! I'm <a href="/about.html">Wojtek Gawroński</a>.<br/>
      I'm a <a href="http://pl.linkedin.com/pub/wojtek-gawroński/58/879/5b0/">software developer</a>.<br/>
      Besides working
      <ul class="interests">
        <li>I write <a href="https://github.com/afronski">code</a></li>
        <li>I <a href="https://twitter.com/afronski">tweet</a></li>
        <li>I give <a href="http://www.afronski.pl/presentations">talks</a></li>
        <li>I <a href="/feed.xml">blog</a></li>
        <li>I <a href="https://www.goodreads.com/user/show/16145105-wojtek-gawro-ski">read books</a></li>
        <li>I <a href="http://www.last.fm/user/afronski">listen music</a></li>
      </ul>

      <nav class="additional-navigation">
        Go to:
        <ul>
          <li><a href="/categories.html">Categories</a></li>
          <li><a href="/tag/series/">Series</a></li>
          <li><a href="/tags.html">Tags</a></li>
        </ul>
      </nav>

      <footer>
        <section>© Copyright 2013, Wojciech Gawroński</section>
        <section>
          Except where otherwise noted, content on this site<br/>
          is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/pl/legalcode">CC BY-NC-ND 3.0</a>.
        </section>
      </footer>
    </aside>

    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-44633104-1','afronski.pl');ga('require', 'displayfeatures');ga('send','pageview');</script>
    <noscript>
      Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>

    <script type="text/javascript">var disqus_shortname="afronskipl";(function(){var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;dsq.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script>
    <script type="text/javascript">!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <script src="//platform.linkedin.com/in.js" type="text/javascript">lang: en_US</script>
    <script>window.fbAsyncInit=function(){FB.init({appId:'801123949972066',xfbml:true,version:'v2.2'});};(function(d,s,id){var js, fjs = d.getElementsByTagName(s)[0];if (d.getElementById(id)) {return;}js = d.createElement(s); js.id = id;js.src = "//connect.facebook.net/en_US/sdk.js";fjs.parentNode.insertBefore(js, fjs);}(document, 'script', 'facebook-jssdk'));</script>
  </body>
</html>
