<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <meta name="author" content="Wojtek Gawroński (afronski)" />
    <meta name="description" content="Personal blog of Wojtek Gawroński, a passionate software developer." />

    <meta name="keywords" content="HTML,HTML5,JavaScript,CSS,CSS3,Canvas,WebGL,C#,.NET,Mono,Erlang,Vagrant,Node.js,Clojure,SICP" />

    <meta name="viewport" content="width=device-width" />

    <link rel="alternate" type="application/rss+xml" title="afronski.pl" href="http://www.afronski.pl/feed.xml" />

<script type="text/javascript" src="/scripts/gdpr.js"></script>
<link rel="stylesheet" type="text/css" href="/stylesheets/gdpr.css" />

    <title>SICP in Clojure - Chapter 3</title>

    <link rel="stylesheet" href="/stylesheets/syntax.min.css" />
    <link rel="stylesheet" href="/stylesheets/main.css" />
  </head>
  <body>
    <section class="ads">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9524821705718873" data-ad-slot="3234654745" data-ad-format="auto"></ins>
    </section>

    <article class="container post">
      <a href="/">Home</a>

<h1 id="sicp-in-clojure---chapter-3">SICP in Clojure - Chapter 3</h1>

<quote class="disclaimer">In one of the <a href="http://www.afronski.pl/books-that-changed-my-career/2015/06/01/books-that-changed-my-career-structure-and-interpretation-of-computer-programs.html">previous blog posts</a> I have announced that I would like to start a new series of posts. It is a persistent journal from my journey through aforementioned book. I hope that you will enjoy it and find it useful - the main goal is to make this series a place where we can return in future, recall ideas and thoughts that accompanied reading process.</quote>

<h3 id="introduction">Introduction</h3>

<p>In the <a href="http://www.afronski.pl/sicp-in-clojure/2015/08/07/sicp-in-clojure-chapter-2.html">previous blog post</a> (which had surprisingly good reception <a href="https://news.ycombinator.com/item?id=10038515">on the Hacker News</a>) we have analyzed second chapter of the book. We did not know, that around the corner there is a ground breaking <em>“twist”</em> prepared by the authors in the 3rd chapter. We will face it today.</p>

<p>I should also mention that recently <a href="http://www.sicpdistilled.com/">SICP Distilled</a> went publicly, which is also a very good tour on the book, with a different approach. Nevertheless, I am still going my way through the book and I have got couple of interesting observations from the aforementioned chapter. But first, I would like to address one question which was posted on the <em>Hacker News</em> thread.</p>

<h3 id="clojure-is-not-a-scheme-and-sicp-will-not-help-you-to-learn-clojure">Clojure is not a Scheme and <code class="highlighter-rouge">SICP</code> will not help you to learn Clojure</h3>

<p>Even if the first part is not debatable at all (how come one language could be identical to another one, even if they have common roots), then the second one is definitely dependent on the point of view. Mine is really obvious - <em>Clojure</em> is my first contact with a <em>Lisp-like</em> language. And book has much more to offer than a simple language course. I would say that a language course and SICP can be complementary. How?</p>

<p>Basically (from my observations) aforementioned book is about <em>good software design</em> and how to approach <em>functional programming</em> and <em>functional design</em> in a <em>dynamicly typed language</em>. It attacks various problems like <em>modularity</em>, <em>data structures</em>, and many more. It provides a good foundation for beginners, and I strongly believe that it can be beneficial for more advanced programmers. By taking that book and completely new language, I am treating this book more like a reference and skeleton - which can be filled when I play with the new language. Of course, it is not a tutorial how to approach a language correctly, in an idiomatic way. Instead, I am building references, analogies and comparisons, which opens a different mode in my head than working with the new language solely. Also, I can focus on the learning by comparison - but I need to be careful, because instead learning new thing, e.g. I can mirror constructs in <em>Clojure</em> which are natural only for <em>Scheme</em>.</p>

<p>Probably because of that someone brought Rich Hickey’s opinion about <code class="highlighter-rouge">SICP</code> to the table:</p>

<quote class="citation">I personally don't think SICP will help you much with Clojure. YMMV.</quote>

<p>And it is hard to argue with that as well - it is <em>true</em>, SICP has nothing to do with learning <em>Clojure</em>. But I can refer to the topics which I already know and thanks to that - learn Clojure at the same time. It is beneficial that I can seek by myself for an idiomatic path to describe the same thing, but in <em>a Clojure way</em>. Of course, there will be plenty of mistakes in the process - but hey, isn’t that the most effective way to learn? <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<h3 id="danger-is-hiding-around-the-corner">Danger is hiding around the corner</h3>

<p>Returning to the main topic - we went more than 200 pages through the book, we built various data structures, simple and not so simple programs which solve certain problems. And around the 215th page (I am referring to <em>Polish</em> edition <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20">) authors introduced concept of <em>mutable state</em>. You may think <em>“oh come on, we are dealing with that on the daily basis”</em>. Why it is so dangerous? Let’s look at the example:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-accumulator</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">start</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">(</span><span class="nf">make-accumulator</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">A</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 15</span><span class="w">
</span><span class="p">(</span><span class="nf">A</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">;; 25</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>If you do not understand what an <code class="highlighter-rouge">atom</code> is, do not worry - we will get <a href="#mutability-in-clojure">there</a>.</p>

<p>Now, I would like to refer to some features that functions without mutable state have. Till now, our functions were fully and only dependent on the input arguments. Taking those values, and body of the function you could clearly reason about the result. Output of that operation could be calculated with the simple substitution method. In other words - our programs were <em>referentially transparent</em> - we could substitute one part of the program with its calculated, simpler version and the result will be still the same. In the example presented above we are not passing state from the previous invocation explicitly - it is buried inside the <em>computation object</em> (in our case an <em>accumulator</em>).</p>

<p>By introducing concept of mutable state, our simple substitution methods are worthless. Functions are not only dependent on arguments, but also on the previous state (<em>local</em> or even worse - <em>global</em> one). We need to deal with the concept of <em>time</em> in our programs. Perfect, by that we just added one more variable to our environment. It means that, our simple invocation of function can cause a <em>side effect</em>. Taking the previous term - our programs became <em>referentially opaque</em>.</p>

<h3 id="what-is-a-side-effect">What is a <em>side effect</em>?</h3>

<p>It is an additional behavior (sometimes deliberate, often unwanted - either unaware or forgotten) in our environment related with the function invocation internals. It is either a mutation of some kind of state, or function invocation, which causes mutation. It means that <em>something</em> in our execution environment is different before and after the function call. Without analyzing body of the function, and its previous states we are not capable of defining what kind of change it is and where it happened. Pretty scary, huh? Well, welcome to the <em>imperative programming</em> world.</p>

<p>It does not mean that imperative programming is particularly bad, you can write pretty clean programs in those languages if you will stick to certain rules and guides. Moreover, all kind of <em>I/O</em> is a <em>side effect</em> - it does not mean that it is bad, but it changes the state - it mutates the environment. It has disadvantages and advantages (sometimes it is simpler to model things in that way - e.g. <code class="highlighter-rouge">random</code> numbers generator which relies on some mutable <em>seed</em> state). I should mention also that there are some languages which are really strict when it comes to the <em>I/O</em>, <em>side effects</em> and execution - one example is <em>Haskell</em> (described <a href="http://www.afronski.pl/7-languages-in-7-weeks/2015/08/26/seven-languages-in-seven-weeks-haskell.html">here</a>). How they enforce strictness on that, is a topic for another blog post - <em>Clojure</em> is different. <strong>It is pragmatic</strong>.</p>

<p>Language philosophy encourages you to write pure, functional core (by that I mean that functions are <em>referentially transparent</em>, without <em>mutable state</em> and <em>side effects</em>). But, it allows you in a very controlled and easy way deal with all kind of <em>side effects</em> and <em>impure</em> peripherals. We will define them later.</p>

<h3 id="another-horrible-consequence-of-mutability">Another, horrible consequence of mutability</h3>

<p>There is one more consequence of mutability. If we will think for a moment, by introducing <em>mutable state</em>, we introduced notions of <em>time</em> and <em>resource ownership</em> (someone is an owner of that mutable state, it does not flow from one call to another via input and output). It means that someone is an owner of a particular state, it can be changed there, but others can also read it. Or even worse - sometimes multiple actors can modify the state. In both cases <em>sharing</em> introduces some really nasty consequences, because it means that time and access to that resource need to be synchronized between multiple parties. <strong>And, as you can imagine, that causes awful lot of problems</strong>.</p>

<h3 id="mutability-in-clojure">Mutability in Clojure</h3>

<p>When you approach <em>Clojure</em> for a first time (especially if you are approaching it with an experiences from <em>imperative programming</em> world), you may think that by creating a <em>global</em> or <em>local</em> <code class="highlighter-rouge">vars</code> via <code class="highlighter-rouge">def</code> it can be shared between multiple execution contexts. Thankfully, you cannot share them - all <code class="highlighter-rouge">vars</code> are isolated. It means that you cannot change it from a different execution context e.g. a <em>thread</em>. Changing state is possible only by rebinding it locally for that context, via <code class="highlighter-rouge">binding</code>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">             </span><span class="c1">;; 2</span><span class="w">

</span><span class="p">(</span><span class="nb">binding</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">          </span><span class="c1">;; 5</span><span class="w">

</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">             </span><span class="c1">;; 2</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>In other words <code class="highlighter-rouge">vars</code> ensure safe use of mutable storage locations via thread isolation. And one more remark - it reminds much more an <em>imperative style</em> of programming, and you have available more of those constructs like <code class="highlighter-rouge">with-local-vars</code> - but, it is not a recommended way to deal with problems in <em>Clojure</em>.</p>

<p>Probably you have heard that <em>Clojure</em> has <em>STM</em> (<em>Software Transactional Memory</em>, exact details about the implementation are gathered <a href="http://clojure.org/refs">here</a>). And that is true, you can ensure shared use of mutable storage thanks to that. But you have to use a different concept - it is called a <code class="highlighter-rouge">ref</code>. They are bound to a single storage location through their lifetime, and allow only to mutate value in that location to happen only within a <em>transaction</em>. Sounds familiar, right? Let’s look at the example:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">pending-jobs</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">active-jobs</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="p">}))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">done-jobs</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="o">#</span><span class="p">{}))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">start-job</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
    </span><span class="p">(</span><span class="nb">commute</span><span class="w"> </span><span class="n">pending-jobs</span><span class="w"> </span><span class="nb">disj</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">commute</span><span class="w"> </span><span class="n">active-jobs</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">id</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">finish-job</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
    </span><span class="p">(</span><span class="nb">commute</span><span class="w"> </span><span class="n">active-job</span><span class="w"> </span><span class="nb">disj</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">commute</span><span class="w"> </span><span class="n">done-jobs</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">id</span><span class="p">)))</span><span class="w">

</span><span class="o">@</span><span class="n">pending-jobs</span><span class="w">     </span><span class="c1">;; #{4 3 2}</span><span class="w">
</span><span class="o">@</span><span class="n">active-jobs</span><span class="w">      </span><span class="c1">;; #{1}</span><span class="w">
</span><span class="o">@</span><span class="n">done-jobs</span><span class="w">        </span><span class="c1">;; #{}</span><span class="w">

</span><span class="p">(</span><span class="nf">finish-job</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="o">@</span><span class="n">pending-jobs</span><span class="w">     </span><span class="c1">;; #{4 3 2}</span><span class="w">
</span><span class="o">@</span><span class="n">active-jobs</span><span class="w">      </span><span class="c1">;; #{}</span><span class="w">
</span><span class="o">@</span><span class="n">done-jobs</span><span class="w">        </span><span class="c1">;; #{1}</span><span class="w">

</span><span class="p">(</span><span class="nf">start-job</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">

</span><span class="o">@</span><span class="n">pending-jobs</span><span class="w">     </span><span class="c1">;; #{4 3}</span><span class="w">
</span><span class="o">@</span><span class="n">active-jobs</span><span class="w">      </span><span class="c1">;; #{2}</span><span class="w">
</span><span class="o">@</span><span class="n">done-jobs</span><span class="w">        </span><span class="c1">;; #{1}</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>In other words - it is a <em>synchronous</em> and <em>synchronized</em> way of altering <em>shared</em> mutable state. Keep in mind that values placed inside a <code class="highlighter-rouge">ref</code> should be <em>immutable</em>. Otherwise something outside of transaction scope attached to a mutable storage can change values inside, and language will not help you in managing that part (in our example we have used plain and immutable <em>Clojure</em> data structure - <em>sets</em>).</p>

<p>In the first example attached in that blog post we have used an <code class="highlighter-rouge">atom</code> as a local state representation. It is an easy way to handle <em>shared</em> state in a <em>synchronous</em> and <em>independent</em> manner. It means that it is an ideal way of having an <em>internal</em>, <em>shared</em> state encapsulated somewhere in the <em>function closure</em>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-monitored</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">condp</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">arg</span><span class="w">
          </span><span class="ss">'reset-count</span><span class="w"> </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
          </span><span class="ss">'how-many-calls?</span><span class="w"> </span><span class="o">@</span><span class="n">counter</span><span class="w">
          </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">arg</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sqr</span><span class="w"> </span><span class="p">(</span><span class="nf">make-monitored</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/sqrt</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="ss">'how-many-calls?</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="mi">25</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="ss">'how-many-calls?</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="ss">'reset-count</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">sqrt</span><span class="w"> </span><span class="ss">'how-many-calls?</span><span class="p">))</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p><em>Agents</em> are last option which <em>Clojure</em> has regarding the mutable storage mechanisms. They are different from the <em>atoms</em>, because state application is <em>asynchronous</em>. You can think about an <code class="highlighter-rouge">agent</code> as a sink, into which we are sending messages. They will be applied asynchronously in the order of receiving them. Let’s look at the example:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">log-sink</span><span class="w"> </span><span class="p">(</span><span class="nb">agent</span><span class="w"> </span><span class="o">'</span><span class="p">()))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">debug</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">send</span><span class="w"> </span><span class="n">log-sink</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"DEBUG: "</span><span class="w"> </span><span class="n">msg</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">send</span><span class="w"> </span><span class="n">log-sink</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"INFO: "</span><span class="w"> </span><span class="n">msg</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; Example presented here is of course simplified, but</span><span class="w">
</span><span class="c1">;; imagine that multiple threads are executing those</span><span class="w">
</span><span class="c1">;; logging statements - in that case, all of them will return</span><span class="w">
</span><span class="c1">;; immediately, and changes will be applied in the order of</span><span class="w">
</span><span class="c1">;; receiving them on the `agent` side.</span><span class="w">

</span><span class="p">(</span><span class="nf">debug</span><span class="w"> </span><span class="s">"1"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">debug</span><span class="w"> </span><span class="s">"2"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">info</span><span class="w"> </span><span class="s">"3"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">debug</span><span class="w"> </span><span class="s">"4"</span><span class="p">)</span><span class="w">

</span><span class="o">@</span><span class="n">log-sink</span><span class="w">     </span><span class="c1">;; ("DEBUG: 4" "INFO: 3" "DEBUG: 2" "DEBUG: 1")</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>We have talked about all options related with <em>mutability</em>, now it is time to check and verify them in practice. Authors of the book prepared something special for us.</p>

<h3 id="designing-system-with-mutability---electronic-circuit-simulator">Designing system with mutability - Electronic Circuit Simulator</h3>

<p>There is a very nice example presented in the book, which implements circuit board simulation. Authors implement it with use of mutable state, represented as an encapsulated <em>computation objects</em>. Let’s look at part of that implementation (whole can be found <a href="https://github.com/afronski/sicp-examples/blob/master/chapters/3/3.3.4/electronic-circuit.clj">here</a>):</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td>
<td class="code"><pre><span class="c1">;; Wires - one of the computational objects in the example.</span><span class="w">
</span><span class="c1">;;</span><span class="w">
</span><span class="c1">;; It represents a *signal state* and list of actions called *effects*</span><span class="w">
</span><span class="c1">;; which are executed after the signal propagates through the wire.</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-signal</span><span class="w"> </span><span class="p">[</span><span class="n">wire</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">wire</span><span class="w"> </span><span class="no">:get-signal</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">set-signal!</span><span class="w"> </span><span class="p">[</span><span class="n">wire</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">((</span><span class="nf">wire</span><span class="w"> </span><span class="no">:set-signal!</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">add-action!</span><span class="w"> </span><span class="p">[</span><span class="n">wire</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="p">((</span><span class="nf">wire</span><span class="w"> </span><span class="no">:add-action!</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-wire</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">signal</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
        </span><span class="n">effects</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">letfn</span><span class="w"> </span><span class="p">[(</span><span class="nf">set-signal!</span><span class="w"> </span><span class="p">[</span><span class="nb">new</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="nb">new</span><span class="p">))</span><span class="w">
                </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="nb">new</span><span class="p">)</span><span class="w">
                    </span><span class="p">(</span><span class="nf">invoke-all</span><span class="w"> </span><span class="o">@</span><span class="n">effects</span><span class="p">))</span><span class="w">
                </span><span class="no">:done</span><span class="p">))</span><span class="w">

            </span><span class="p">(</span><span class="nf">add-action!</span><span class="w"> </span><span class="p">[</span><span class="n">procedure</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">effects</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">procedure</span><span class="p">)</span><span class="w">
              </span><span class="p">(</span><span class="nf">procedure</span><span class="p">))</span><span class="w">

            </span><span class="p">(</span><span class="nf">dispatch</span><span class="w"> </span><span class="p">[</span><span class="n">action</span><span class="p">]</span><span class="w">
              </span><span class="p">(</span><span class="nf">condp</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">action</span><span class="w">
                </span><span class="no">:get-signal</span><span class="w"> </span><span class="o">@</span><span class="n">signal</span><span class="w">
                </span><span class="no">:set-signal!</span><span class="w"> </span><span class="n">set-signal!</span><span class="w">
                </span><span class="no">:add-action!</span><span class="w"> </span><span class="n">add-action!</span><span class="w">
                </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Unknown operation "</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="s">" in make-wire."</span><span class="p">))))]</span><span class="w">
      </span><span class="n">dispatch</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; ...</span><span class="w">

</span><span class="c1">;; Adders - the functional composition of previously defined smaller elements, with</span><span class="w">
</span><span class="c1">;; use of local computational objects with state, represented by wires.</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">half-adder</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">)</span><span class="w">
        </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">or-gate</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">and-gate</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">not-gate</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">and-gate</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
    </span><span class="no">:ok</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">full-adder</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c-in</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">c-out</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">)</span><span class="w">
        </span><span class="n">c1</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">)</span><span class="w">
        </span><span class="n">c2</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">half-adder</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c-in</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">half-adder</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">or-gate</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="n">c-out</span><span class="p">)</span><span class="w">
    </span><span class="no">:ok</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Simulation - the actual use of the system. Scheduling, gate propagation</span><span class="w">
</span><span class="c1">;; delay and agenda are hidden underneath the `step` and `set-signal!` functions.</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">input-1</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">input-2</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="p">(</span><span class="nf">make-wire</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">probe</span><span class="w"> </span><span class="no">:sum</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">probe</span><span class="w"> </span><span class="no">:carry</span><span class="w"> </span><span class="n">carry</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">half-adder</span><span class="w"> </span><span class="n">input-1</span><span class="w"> </span><span class="n">input-2</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">carry</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">set-signal!</span><span class="w"> </span><span class="n">input-1</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">step</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">set-signal!</span><span class="w"> </span><span class="n">input-2</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">step</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Even if using the system, is really easy (last part is actually a very pleasant and simple <em>DSL</em>) - reasoning about the state is definitely harder. I encourage you to analyze the actual implementation (and how the <em>agenda</em> mechanism works).</p>

<h3 id="laziness">Laziness</h3>

<p>Before we will move to the next chapter, authors introduced a <em>stream</em> concept, which is a lazy sequence. It means that only the first value is available and tail will be calculated on demand afterwards (or will not - depends on the further execution flow). In <em>Scheme</em> you have to build such thing by yourself, in <em>Clojure</em> - you have got all facilities in place already:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">integers-from</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">integers-from</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">integers</span><span class="w"> </span><span class="p">(</span><span class="nf">integers-from</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">integers</span><span class="p">))</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Keep in mind that we are using the same functions from the <code class="highlighter-rouge">Seq</code> interface (<code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">rest</code> and <code class="highlighter-rouge">cons</code>) despite that the actual sequence is evaluated lazily. In more comprehensive <a href="https://github.com/afronski/sicp-examples/blob/master/chapters/3/3.5.2/infinite-streams.clj">example</a> you can see how you can use filtering or mapping together with laziness.</p>

<h3 id="using-streams-or-rather---why-laziness-is-a-good-thing">Using streams, or rather - why laziness is a good thing?</h3>

<p>When you read previous section, you probably have a feeling that laziness introduces a better way for handling state. It optimizes certain use cases, because often we do not want to calculate and proceed operations on all elements. Indeed, that is a <em>better way</em> to approach problem of state succession - but, keep in mind that all performed operations that have side effects can be problematic. It means that some parts of the code would not be evaluated, so side effects will not be applied either - what if something, down in the guts of the system relies on that? That is another reason why mutation causes unexpected problems.</p>

<p>In the last section of the chapter authors compared modularity of the <em>functional design</em> and <em>objects</em>. They have prepared an <a href="https://github.com/afronski/sicp-examples/blob/master/chapters/3/3.5.5/monte-carlo.clj">interesting example</a> which combines <em>computational object</em> and underneath uses <em>streams</em> (and in consequence, <em>lazy sequences</em>):</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="code"><pre><span class="c1">;; Monte Carlo method as a stream (you are increasing number</span><span class="w">
</span><span class="c1">;; of iterations by taking more elements from the stream).</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">monte-carlo</span><span class="w"> </span><span class="p">[</span><span class="n">experiment-as-stream</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="n">failed</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">letfn</span><span class="w"> </span><span class="p">[(</span><span class="nb">next</span><span class="w"> </span><span class="p">[</span><span class="n">passed</span><span class="w"> </span><span class="n">failed</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="n">failed</span><span class="p">))</span><span class="w">
                  </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">monte-carlo</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">experiment-as-stream</span><span class="p">)</span><span class="w">
                                         </span><span class="n">passed</span><span class="w">
                                         </span><span class="n">failed</span><span class="p">))))]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">experiment-as-stream</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">passed</span><span class="p">)</span><span class="w"> </span><span class="n">failed</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">failed</span><span class="p">)))))</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>It is an implementation of <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo simulation method</a>. It is based on the streams - they are responsible for transformation and representing simulation itself, and has simple <em>computational object</em> which represents <em>random number generator</em> (with internal and <em>mutable</em> state).</p>

<h3 id="summary">Summary</h3>

<p>It was a <em>very long article</em>, with a lot of twists and a groundbreaking truth. For developers with some experience (especially related with <em>multi-threading</em> and <em>concurrency</em>) it is probably a bread and butter - that is why we are unconsciously got used to it. Change and reflection about state of our tools requires fresh point of view, a new perspective. I hope that by reading those kind of books I will easily get one. And thanks to that I will be able to rethink my daily practices, and obviously learn new stuff.</p>

<p>See you next time, in the blog post about 4th chapter! <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<h3 id="credits">Credits</h3>

<ul>
  <li>
<a href="http://mitpress.mit.edu/books/structure-and-interpretation-computer-programs">Structure and Interpretation of Computer Programs</a>, <em>Harold Abelson</em>, <em>Gerald Jay Sussman</em> and <em>Julie Sussman</em>
</li>
  <li><a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">Full book available online</a></li>
  <li><a href="https://github.com/afronski/sicp-examples">afronski/sicp-examples</a></li>
  <li><a href="http://www.sicpdistilled.com/">SICP Distilled</a></li>
</ul>

    </article>

    <section class="container">
      <a href="/" class="mobile-link">Home</a>
    </section>

    <aside class="menu">

      <a href="http://www.afronski.pl">
        <img id="avatar" src="/images/avatar.png" alt="My avatar">
      </a>

      Hello! I'm <a href="/about.html">Wojtek Gawroński</a>.<br>
      I'm a <a href="https://www.linkedin.com/in/afronski">software developer</a>.<br>
      Besides working
      <ul class="interests">
        <li>I write <a href="https://github.com/afronski">code</a>
</li>
        <li>I <a href="https://twitter.com/afronski">tweet</a>
</li>
        <li>I <a href="https://awsgentleman.com">blog about <em>AWS</em></a>
</li>
        <li>I <a href="https://www.goodreads.com/user/show/16145105-wojtek-gawro-ski">read books</a>
</li>
      </ul>

      <footer>
        <section>© Copyright 2013 - 2020, Wojciech Gawroński</section>
        <section>
          Except where otherwise noted, content on this site<br>
          is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/pl/legalcode">CC BY-NC-ND 3.0</a>.
        </section>
      </footer>
    </aside>

    <script>document.addEventListener("gdprCookiesEnabled", function (event) {if(!event.detail.analytics){window['ga-disable-UA-44633104-1'] = true;};if(event.detail.marketing){(adsbygoogle=window.adsbygoogle||[]).push({});}});</script>
    <script>gdprCookieNotice({locale:"en",timeout:500,expiration:30,domain:".afronski.pl",implicit:true,statement:"http://www.afronski.pl/cookies.html",performance:["sessionid"],analytics:["_ga","_gid","_gat","twid","c_user"],marketing:["SID","SIDCC","SAPISID","S","SSID","OGPC","NID","HSID","CONSENT","APISID","1P_JAR"]});</script>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-44633104-1','afronski.pl');ga('require','displayfeatures');ga('send','pageview');</script>

  </body>
</html>
